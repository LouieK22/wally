use std::collections::BTreeMap;
use std::path::Path;
use std::{
    fs::read_to_string,
    io::{self, BufWriter, Write},
};

use fs_err::File;
use semver::Version;
use serde::{Deserialize, Serialize};

use crate::package_id;
use crate::{
    manifest::Manifest, package_id::PackageId, package_name::PackageName, resolution::Resolve,
};

pub const LOCKFILE_NAME: &str = "wally.lock";

#[derive(Debug, Serialize, Deserialize)]
pub struct Lockfile {
    pub registry: String,

    #[serde(rename = "package")]
    pub packages: Vec<LockPackage>,
}

fn grab_dependencies(
    package_id: &PackageId,
    dependencies: &BTreeMap<
        package_id::PackageId,
        BTreeMap<std::string::String, package_id::PackageId>,
    >,
) -> Vec<(String, PackageId)> {
    dependencies
        .get(package_id)
        .map(|dependencies| {
            dependencies
                .iter()
                .map(|(key, value)| (key.clone(), value.clone()))
                .collect()
        })
        .unwrap_or_else(Vec::new)
}

impl Lockfile {
    pub fn from_manifest(manifest: &Manifest) -> Self {
        Self {
            registry: manifest.package.registry.clone(),
            packages: Vec::new(),
        }
    }

    pub fn from_resolve(resolve: &Resolve) -> Self {
        let mut packages = Vec::new();

        for package_id in &resolve.activated {
            let dependencies = [
                grab_dependencies(&package_id, &resolve.shared_dependencies),
                grab_dependencies(&package_id, &resolve.server_dependencies),
                grab_dependencies(&package_id, &resolve.dev_dependencies),
            ]
            .concat();

            packages.push(LockPackage::Registry(RegistryLockPackage {
                name: package_id.name().clone(),
                version: package_id.version().clone(),
                checksum: None,
                dependencies,
            }));
        }

        Self {
            registry: "test".to_owned(),
            packages,
        }
    }

    pub fn load(project_path: &Path) -> anyhow::Result<Option<Self>> {
        let lockfile_path = project_path.join(LOCKFILE_NAME);
        let contents = match read_to_string(&lockfile_path) {
            Ok(contents) => contents,
            Err(err) => {
                if err.kind() == io::ErrorKind::NotFound {
                    return Ok(None);
                } else {
                    return Err(err.into());
                }
            }
        };
        Ok(Some(toml::from_str(&contents)?))
    }

    pub fn save(&self, project_path: &Path) -> anyhow::Result<()> {
        let lockfile_path = project_path.join(LOCKFILE_NAME);

        let mut file = BufWriter::new(File::create(lockfile_path)?);
        writeln!(file, "# This file is automatically @generated by Wally.")?;
        writeln!(file, "# It is not intended for manual editing.")?;
        writeln!(file, "registry = \"{}\"", self.registry)?;
        writeln!(file, "")?;

        for lock_package in self.packages.iter() {
            writeln!(file, "[[package]]")?;

            match lock_package {
                LockPackage::Registry(registry_lock_package) => {
                    writeln!(file, "name = \"{}\"", registry_lock_package.name)?;
                    writeln!(file, "version = \"{}\"", registry_lock_package.version)?;

                    if let Some(checksum) = &registry_lock_package.checksum {
                        writeln!(file, "checksum = \"{}\"", checksum)?;
                    }

                    if registry_lock_package.dependencies.len() == 0 {
                        writeln!(file, "dependencies = []")?;
                    } else {
                        writeln!(file, "dependencies = [")?;
                        for dependency in registry_lock_package.dependencies.iter() {
                            writeln!(file, "\t[\"{}\", \"{}\"],", dependency.0, dependency.1)?;
                        }
                        writeln!(file, "]")?;
                    }
                }
                LockPackage::Git(git_lock_package) => {
                    writeln!(file, "name = \"{}\"", git_lock_package.name)?;
                    writeln!(file, "rev = \"{}\"", git_lock_package.rev)?;
                    writeln!(file, "commit = \"{}\"", git_lock_package.commit)?;

                    if git_lock_package.dependencies.len() == 0 {
                        writeln!(file, "dependencies = []")?;
                    } else {
                        writeln!(file, "dependencies = [")?;
                        for dependency in git_lock_package.dependencies.iter() {
                            writeln!(file, "\t\"{}\",", dependency)?;
                        }
                        writeln!(file, "]")?;
                    }
                }
            }

            writeln!(file, "")?;
        }

        file.flush()?;

        Ok(())
    }

    pub fn as_ids(&self) -> impl Iterator<Item = PackageId> + '_ {
        self.packages.iter().map(|lock_package| match lock_package {
            LockPackage::Registry(lock_package) => {
                PackageId::new(lock_package.name.clone(), lock_package.version.clone())
            }
            LockPackage::Git(_) => todo!(),
        })
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LockPackage {
    Registry(RegistryLockPackage),
    Git(GitLockPackage),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RegistryLockPackage {
    pub name: PackageName,
    pub version: Version,
    pub checksum: Option<String>,

    #[serde(default)]
    pub dependencies: Vec<(String, PackageId)>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GitLockPackage {
    pub name: String,
    pub rev: String,
    pub commit: String,

    #[serde(default)]
    pub dependencies: Vec<PackageId>,
}
